Great! Now let's upload your game file. Here's exactly what to do:

## üìÅ **Upload Your Game File**

### **Step 1: Create the Game File**
1. **Look for a link** that says **"creating a new file"** or click **"Add file" ‚Üí "Create new file"**

2. **In the filename box**, type: `index.html`

3. **In the large code box below**, copy and paste this entire code:
Action: file_editor view /app/frontend/public/ultra-donkey-glide.html
Observation: /app/frontend/public/ultra-donkey-glide.html:
1|<!DOCTYPE html>
2|<html lang="en">
3|<head>
4|    <meta charset="UTF-8">
5|    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
6|    <title>N√òBLEAK: Donkey Glide - Ultra Performance</title>
7|    <style>
8|        * { margin: 0; padding: 0; box-sizing: border-box; }
9|        body {
10|            font-family: Arial, sans-serif;
11|            background: #990000;
12|            overflow: hidden;
13|            user-select: none;
14|            touch-action: none;
15|            position: fixed;
16|            width: 100%;
17|            height: 100%;
18|            will-change: transform;
19|        }
20|        #gameContainer {
21|            display: flex;
22|            align-items: center;
23|            justify-content: center;
24|            width: 100vw;
25|            height: 100vh;
26|            background: linear-gradient(135deg, #990000, #FF0000, #FFFFFF);
27|        }
28|        #gameCanvas {
29|            border: 3px solid #FF0000;
30|            border-radius: 6px;
31|            cursor: pointer;
32|            image-rendering: pixelated;
33|            image-rendering: -moz-crisp-edges;
34|            image-rendering: crisp-edges;
35|            will-change: transform;
36|        }
37|        .overlay {
38|            position: absolute;
39|            top: 0;
40|            left: 0;
41|            width: 100%;
42|            height: 100%;
43|            background: rgba(0,0,0,0.85);
44|            display: flex;
45|            flex-direction: column;
46|            align-items: center;
47|            justify-content: center;
48|            color: white;
49|            text-align: center;
50|            z-index: 1000;
51|            will-change: opacity;
52|        }
53|        .title {
54|            font-size: clamp(2rem, 8vw, 4rem);
55|            font-weight: bold;
56|            color: #FF0000;
57|            text-shadow: 0 0 10px rgba(255,0,0,0.5);
58|            margin-bottom: 0.5rem;
59|        }
60|        .subtitle {
61|            font-size: clamp(1rem, 4vw, 1.5rem);
62|            color: #FFCCCC;
63|            margin-bottom: 1rem;
64|        }
65|        .btn {
66|            background: linear-gradient(45deg, #FF0000, #CC0000);
67|            border: 2px solid #FFFFFF;
68|            color: white;
69|            padding: 0.8rem 1.5rem;
70|            font-size: clamp(1rem, 3vw, 1.1rem);
71|            font-weight: bold;
72|            border-radius: 4px;
73|            cursor: pointer;
74|            margin: 0.3rem;
75|            transition: transform 0.1s;
76|            will-change: transform;
77|        }
78|        .btn:active {
79|            transform: scale(0.95);
80|        }
81|        .stats {
82|            display: flex;
83|            gap: 1.5rem;
84|            margin: 0.8rem 0;
85|            font-size: clamp(0.9rem, 3vw, 1rem);
86|        }
87|        .ui {
88|            position: absolute;
89|            top: 8px;
90|            left: 8px;
91|            color: white;
92|            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
93|            font-size: clamp(1rem, 4vw, 1.1rem);
94|            font-weight: bold;
95|            z-index: 100;
96|            pointer-events: none;
97|        }
98|        .controls {
99|            position: absolute;
100|            top: 8px;
101|            right: 8px;
102|            color: white;
103|            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
104|            font-size: clamp(0.8rem, 3vw, 0.9rem);
105|            text-align: right;
106|            z-index: 100;
107|            pointer-events: none;
108|        }
109|        .brand {
110|            position: absolute;
111|            bottom: 8px;
112|            left: 50%;
113|            transform: translateX(-50%);
114|            color: rgba(255,255,255,0.4);
115|            font-size: clamp(0.7rem, 2vw, 0.8rem);
116|            pointer-events: none;
117|        }
118|    </style>
119|</head>
120|<body>
121|    <div id="gameContainer">
122|        <canvas id="gameCanvas"></canvas>
123|        
124|        <div id="startScreen" class="overlay">
125|            <div class="title">N√òBLEAK</div>
126|            <div class="subtitle">Donkey Glide</div>
127|            <p style="margin: 0.8rem; opacity: 0.8; max-width: 300px;">TAP or SPACE to glide through chaos</p>
128|            <button class="btn" onclick="startGame()">START GLIDING</button>
129|            <div class="stats">
130|                <div>Best: <span id="bestScore">0</span></div>
131|            </div>
132|        </div>
133|        
134|        <div id="gameOverScreen" class="overlay" style="display: none;">
135|            <div class="title">GAME OVER</div>
136|            <div class="stats">
137|                <div>Score: <span id="finalScore">0</span></div>
138|                <div>Coins: <span id="totalCoins">0</span></div>
139|            </div>
140|            <div id="newRecord" style="display: none; color: #FF0000; font-size: 1.3rem; margin: 0.8rem;">üèÜ NEW RECORD!</div>
141|            <button class="btn" onclick="startGame()">PLAY AGAIN</button>
142|        </div>
143|        
144|        <div class="ui">
145|            <div>Score: <span id="score">0</span></div>
146|            <div style="font-size: 0.8em; opacity: 0.7;">Best: <span id="highScore">0</span></div>
147|        </div>
148|        
149|        <div class="controls">
150|            <div>TAP / SPACE</div>
151|        </div>
152|        
153|        <div class="brand">N√òBLEAK Energy</div>
154|    </div>
155|
156|    <script>
157|        'use strict';
158|        
159|        // Ultra-optimized game engine
160|        class UltraGame {
161|            constructor() {
162|                this.canvas = document.getElementById('gameCanvas');
163|                this.ctx = this.canvas.getContext('2d', {
164|                    alpha: false,
165|                    desynchronized: true,
166|                    willReadFrequently: false
167|                });
168|                
169|                this.setupCanvas();
170|                this.initObjectPools();
171|                this.bindEvents();
172|                
173|                this.gameState = 'start';
174|                this.score = 0;
175|                this.coins = 0;
176|                this.highScore = parseInt(localStorage.getItem('nobleak-best') || '0');
177|                
178|                // Performance tracking
179|                this.lastTime = 0;
180|                this.frameCount = 0;
181|                this.skipFrame = false;
182|                
183|                // Pre-calculated values
184|                this.halfWidth = 0;
185|                this.halfHeight = 0;
186|                
187|                this.updateUI();
188|            }
189|            
190|            setupCanvas() {
191|                // Optimal canvas size for performance
192|                const w = Math.min(760, window.innerWidth * 0.95) | 0;
193|                const h = Math.min(500, window.innerHeight * 0.8) | 0;
194|                
195|                this.canvas.width = w;
196|                this.canvas.height = h;
197|                this.halfWidth = w >> 1;
198|                this.halfHeight = h >> 1;
199|                
200|                // Ultra performance settings
201|                this.ctx.imageSmoothingEnabled = false;
202|                this.ctx.textBaseline = 'top';
203|                this.ctx.lineCap = 'square';
204|                this.ctx.lineJoin = 'miter';
205|                
206|                // Pre-create gradient (expensive operation)
207|                this.bgGradient = this.ctx.createLinearGradient(0, 0, 0, h);
208|                this.bgGradient.addColorStop(0, '#FF0000');
209|                this.bgGradient.addColorStop(0.5, '#FFFFFF');
210|                this.bgGradient.addColorStop(1, '#CC0000');
211|            }
212|            
213|            initObjectPools() {
214|                // Object pooling to eliminate garbage collection
215|                this.obstaclePool = [];
216|                this.coinPool = [];
217|                this.particlePool = [];
218|                this.bgPool = [];
219|                
220|                // Pre-allocate objects
221|                for (let i = 0; i < 20; i++) {
222|                    this.obstaclePool[i] = { x: 0, y: 0, w: 0, h1: 0, h2: 0, active: false, passed: false };
223|                    this.coinPool[i] = { x: 0, y: 0, rot: 0, active: false };
224|                    this.particlePool[i] = { x: 0, y: 0, vx: 0, vy: 0, life: 0, active: false };
225|                    this.bgPool[i] = { x: 0, y: 0, text: '', size: 0, opacity: 0, active: false };
226|                }
227|            }
228|            
229|            bindEvents() {
230|                let isHandling = false;
231|                
232|                const handleInput = (e) => {
233|                    if (isHandling) return;
234|                    isHandling = true;
235|                    e.preventDefault();
236|                    this.jump();
237|                    setTimeout(() => isHandling = false, 50);
238|                };
239|                
240|                this.canvas.addEventListener('touchstart', handleInput, { passive: false });
241|                this.canvas.addEventListener('mousedown', handleInput);
242|                this.canvas.addEventListener('contextmenu', e => e.preventDefault());
243|                
244|                document.addEventListener('keydown', (e) => {
245|                    if (e.code === 'Space') handleInput(e);
246|                });
247|                
248|                // Prevent scrolling and zoom
249|                document.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
250|                document.addEventListener('gesturestart', e => e.preventDefault());
251|            }
252|            
253|            initGame() {
254|                this.gameState = 'playing';
255|                this.score = 0;
256|                this.coins = 0;
257|                
258|                // Reset all pools
259|                this.obstaclePool.forEach(obj => obj.active = false);
260|                this.coinPool.forEach(obj => obj.active = false);
261|                this.particlePool.forEach(obj => obj.active = false);
262|                this.bgPool.forEach(obj => obj.active = false);
263|                
264|                // Game state
265|                this.donkey = {
266|                    x: 80,
267|                    y: this.halfHeight,
268|                    w: 32,
269|                    h: 32,
270|                    vy: 0,
271|                    rot: 0,
272|                    canJump: true,
273|                    cooldown: 0
274|                };
275|                
276|                this.speed = 2.2;
277|                this.gravity = 0.28;
278|                this.jumpPower = -5.8;
279|                
280|                this.spawnTimer = 0;
281|                this.coinTimer = 0;
282|                this.bgTimer = 0;
283|                
284|                // Initialize background elements
285|                for (let i = 0; i < 6; i++) {
286|                    const bg = this.bgPool[i];
287|                    bg.x = Math.random() * this.canvas.width * 1.5;
288|                    bg.y = Math.random() * this.canvas.height;
289|                    bg.text = Math.random() < 0.7 ? 'N√òBLEAK' : 'USE THE RICH';
290|                    bg.size = 12 + (Math.random() * 12) | 0;
291|                    bg.opacity = 0.08 + Math.random() * 0.12;
292|                    bg.active = true;
293|                }
294|                
295|                this.updateUI();
296|                this.lastTime = performance.now();
297|                this.gameLoop();
298|            }
299|            
300|            gameLoop(currentTime) {
301|                if (this.gameState !== 'playing') return;
302|                
303|                const dt = currentTime - this.lastTime;
304|                this.lastTime = currentTime;
305|                
306|                // Skip frame if too slow (maintain 60fps)
307|                this.frameCount++;
308|                if (dt > 20 && this.frameCount % 2 === 0) {
309|                    requestAnimationFrame(t => this.gameLoop(t));
310|                    return;
311|                }
312|                
313|                this.update(dt);
314|                this.render();
315|                
316|                requestAnimationFrame(t => this.gameLoop(t));
317|            }
318|            
319|            update(dt) {
320|                const d = this.donkey;
321|                
322|                // Physics (optimized)
323|                d.vy += this.gravity;
324|                d.y += d.vy;
325|                d.rot = Math.max(-20, Math.min(20, d.vy * 1.8)) | 0;
326|                
327|                // Jump cooldown
328|                if (d.cooldown > 0) {
329|                    d.cooldown--;
330|                    if (d.cooldown === 0) d.canJump = true;
331|                }
332|                
333|                // Spawning (optimized timers)
334|                this.spawnTimer++;
335|                if (this.spawnTimer > 140) {
336|                    this.spawnTimer = 0;
337|                    this.spawnObstacle();
338|                }
339|                
340|                this.coinTimer++;
341|                if (this.coinTimer > 100) {
342|                    this.coinTimer = 0;
343|                    if (Math.random() < 0.55) this.spawnCoin();
344|                }
345|                
346|                // Update obstacles
347|                for (let i = 0; i < this.obstaclePool.length; i++) {
348|                    const obs = this.obstaclePool[i];
349|                    if (!obs.active) continue;
350|                    
351|                    obs.x -= this.speed;
352|                    
353|                    if (!obs.passed && obs.x + obs.w < d.x) {
354|                        obs.passed = true;
355|                        this.addScore(1);
356|                    }
357|                    
358|                    if (obs.x < -60) obs.active = false;
359|                }
360|                
361|                // Update coins
362|                for (let i = 0; i < this.coinPool.length; i++) {
363|                    const coin = this.coinPool[i];
364|                    if (!coin.active) continue;
365|                    
366|                    coin.x -= this.speed;
367|                    coin.rot += 3;
368|                    
369|                    // Collision check (inlined for performance)
370|                    if (d.x < coin.x + 18 && d.x + d.w > coin.x &&
371|                        d.y < coin.y + 18 && d.y + d.h > coin.y) {
372|                        coin.active = false;
373|                        this.addScore(5);
374|                        this.coins++;
375|                        this.addParticles(coin.x + 9, coin.y + 9);
376|                    }
377|                    
378|                    if (coin.x < -30) coin.active = false;
379|                }
380|                
381|                // Update particles
382|                for (let i = 0; i < this.particlePool.length; i++) {
383|                    const p = this.particlePool[i];
384|                    if (!p.active) continue;
385|                    
386|                    p.x += p.vx;
387|                    p.y += p.vy;
388|                    p.vy += 0.1;
389|                    p.life--;
390|                    
391|                    if (p.life <= 0) p.active = false;
392|                }
393|                
394|                // Update background
395|                for (let i = 0; i < this.bgPool.length; i++) {
396|                    const bg = this.bgPool[i];
397|                    if (!bg.active) continue;
398|                    
399|                    bg.x -= this.speed * 0.25;
400|                    if (bg.x < -80) {
401|                        bg.x = this.canvas.width + 20;
402|                        bg.y = Math.random() * this.canvas.height;
403|                    }
404|                }
405|                
406|                // Collision detection (optimized)
407|                this.checkCollisions();
408|                
409|                // Boundary check
410|                if (d.y < 0 || d.y + d.h > this.canvas.height) {
411|                    this.endGame();
412|                }
413|            }
414|            
415|            spawnObstacle() {
416|                const obs = this.getInactiveObstacle();
417|                if (!obs) return;
418|                
419|                const gap = 120;
420|                const minH = 40;
421|                const maxH = this.canvas.height - gap - minH;
422|                const topH = minH + (Math.random() * maxH) | 0;
423|                
424|                obs.x = this.canvas.width;
425|                obs.y = 0;
426|                obs.w = 45;
427|                obs.h1 = topH;
428|                obs.h2 = this.canvas.height - (topH + gap);
429|                obs.active = true;
430|                obs.passed = false;
431|            }
432|            
433|            spawnCoin() {
434|                const coin = this.getInactiveCoin();
435|                if (!coin) return;
436|                
437|                coin.x = this.canvas.width;
438|                coin.y = 30 + (Math.random() * (this.canvas.height - 60)) | 0;
439|                coin.rot = 0;
440|                coin.active = true;
441|            }
442|            
443|            addParticles(x, y) {
444|                for (let i = 0; i < 4; i++) {
445|                    const p = this.getInactiveParticle();
446|                    if (!p) break;
447|                    
448|                    p.x = x;
449|                    p.y = y;
450|                    p.vx = (Math.random() - 0.5) * 6;
451|                    p.vy = (Math.random() - 0.5) * 6;
452|                    p.life = 20;
453|                    p.active = true;
454|                }
455|            }
456|            
457|            checkCollisions() {
458|                const d = this.donkey;
459|                
460|                for (let i = 0; i < this.obstaclePool.length; i++) {
461|                    const obs = this.obstaclePool[i];
462|                    if (!obs.active) continue;
463|                    
464|                    if (d.x < obs.x + obs.w && d.x + d.w > obs.x) {
465|                        if (d.y < obs.h1 || d.y + d.h > obs.h1 + 120) {
466|                            this.endGame();
467|                            return;
468|                        }
469|                    }
470|                }
471|            }
472|            
473|            render() {
474|                const ctx = this.ctx;
475|                const w = this.canvas.width;
476|                const h = this.canvas.height;
477|                
478|                // Background (single draw call)
479|                ctx.fillStyle = this.bgGradient;
480|                ctx.fillRect(0, 0, w, h);
481|                
482|                // Background text (batched)
483|                ctx.font = 'bold 14px Arial';
484|                ctx.textAlign = 'center';
485|                for (let i = 0; i < this.bgPool.length; i++) {
486|                    const bg = this.bgPool[i];
487|                    if (!bg.active) continue;
488|                    
489|                    ctx.save();
490|                    ctx.globalAlpha = bg.opacity;
491|                    ctx.fillStyle = '#FF0000';
492|                    ctx.font = `bold ${bg.size}px Arial`;
493|                    ctx.fillText(bg.text, bg.x | 0, bg.y | 0);
494|                    ctx.restore();
495|                }
496|                
497|                ctx.globalAlpha = 1;
498|                
499|                // Obstacles (batched white fills)
500|                ctx.fillStyle = '#FFFFFF';
501|                for (let i = 0; i < this.obstaclePool.length; i++) {
502|                    const obs = this.obstaclePool[i];
503|                    if (!obs.active) continue;
504|                    
505|                    ctx.fillRect(obs.x | 0, 0, obs.w, obs.h1);
506|                    ctx.fillRect(obs.x | 0, (obs.h1 + 120) | 0, obs.w, obs.h2);
507|                }
508|                
509|                // Graffiti (batched red text)
510|                ctx.fillStyle = '#FF0000';
511|                ctx.font = 'bold 10px Arial';
512|                ctx.textAlign = 'center';
513|                for (let i = 0; i < this.obstaclePool.length; i++) {
514|                    const obs = this.obstaclePool[i];
515|                    if (!obs.active || obs.h1 < 30) continue;
516|                    
517|                    ctx.fillText('N√òBLEAK', (obs.x + obs.w/2) | 0, (obs.h1 - 12) | 0);
518|                }
519|                
520|                // Coins (optimized rendering)
521|                for (let i = 0; i < this.coinPool.length; i++) {
522|                    const coin = this.coinPool[i];
523|                    if (!coin.active) continue;
524|                    
525|                    ctx.save();
526|                    ctx.translate((coin.x + 9) | 0, (coin.y + 9) | 0);
527|                    ctx.rotate(coin.rot * 0.0174533); // Pre-calculated PI/180
528|                    ctx.fillStyle = '#FF0000';
529|                    ctx.fillRect(-9, -9, 18, 18);
530|                    ctx.fillStyle = '#FFFFFF';
531|                    ctx.font = 'bold 14px Arial';
532|                    ctx.textAlign = 'center';
533|                    ctx.fillText('$', 0, -2);
534|                    ctx.restore();
535|                }
536|                
537|                // Particles (single color, batched)
538|                ctx.fillStyle = '#FF0000';
539|                for (let i = 0; i < this.particlePool.length; i++) {
540|                    const p = this.particlePool[i];
541|                    if (!p.active) continue;
542|                    
543|                    ctx.save();
544|                    ctx.globalAlpha = p.life / 20;
545|                    ctx.fillRect(p.x | 0, p.y | 0, 2, 2);
546|                    ctx.restore();
547|                }
548|                
549|                // Donkey (optimized)
550|                this.renderDonkey();
551|            }
552|            
553|            renderDonkey() {
554|                const ctx = this.ctx;
555|                const d = this.donkey;
556|                
557|                ctx.save();
558|                ctx.translate((d.x + 16) | 0, (d.y + 16) | 0);
559|                ctx.rotate(d.rot * 0.0174533);
560|                
561|                // Body
562|                ctx.fillStyle = '#FF0000';
563|                ctx.fillRect(-16, -16, 32, 32);
564|                
565|                // Head
566|                ctx.fillStyle = '#FF3333';
567|                ctx.fillRect(-14, -14, 28, 14);
568|                
569|                // Ears
570|                ctx.fillStyle = '#FF0000';
571|                ctx.fillRect(-12, -18, 6, 8);
572|                ctx.fillRect(6, -18, 6, 8);
573|                
574|                // Sunglasses
575|                ctx.fillStyle = '#000000';
576|                ctx.fillRect(-12, -8, 24, 8);
577|                ctx.fillStyle = '#333333';
578|                ctx.fillRect(-10, -6, 7, 4);
579|                ctx.fillRect(3, -6, 7, 4);
580|                
581|                // Reflections
582|                ctx.fillStyle = '#FFFFFF';
583|                ctx.fillRect(-9, -5, 2, 2);
584|                ctx.fillRect(4, -5, 2, 2);
585|                
586|                // Snout
587|                ctx.fillStyle = '#FF6666';
588|                ctx.fillRect(-10, 0, 20, 6);
589|                
590|                // Details
591|                ctx.fillStyle = '#000000';
592|                ctx.fillRect(-6, 1, 2, 2);
593|                ctx.fillRect(4, 1, 2, 2);
594|                ctx.fillRect(-8, 4, 16, 1);
595|                
596|                ctx.restore();
597|            }
598|            
599|            // Object pool getters (inlined for performance)
600|            getInactiveObstacle() {
601|                for (let i = 0; i < this.obstaclePool.length; i++) {
602|                    if (!this.obstaclePool[i].active) return this.obstaclePool[i];
603|                }
604|                return null;
605|            }
606|            
607|            getInactiveCoin() {
608|                for (let i = 0; i < this.coinPool.length; i++) {
609|                    if (!this.coinPool[i].active) return this.coinPool[i];
610|                }
611|                return null;
612|            }
613|            
614|            getInactiveParticle() {
615|                for (let i = 0; i < this.particlePool.length; i++) {
616|                    if (!this.particlePool[i].active) return this.particlePool[i];
617|                }
618|                return null;
619|            }
620|            
621|            jump() {
622|                if (this.gameState === 'playing' && this.donkey.canJump) {
623|                    this.donkey.vy = this.jumpPower;
624|                    this.donkey.canJump = false;
625|                    this.donkey.cooldown = 10;
626|                }
627|            }
628|            
629|            addScore(points) {
630|                this.score += points;
631|                if (this.score % 50 === 0 && this.speed < 3.5) {
632|                    this.speed += 0.1; // Progressive difficulty
633|                }
634|                this.updateUI();
635|            }
636|            
637|            updateUI() {
638|                document.getElementById('score').textContent = this.score;
639|                document.getElementById('highScore').textContent = this.highScore;
640|                document.getElementById('bestScore').textContent = this.highScore;
641|            }
642|            
643|            endGame() {
644|                this.gameState = 'gameOver';
645|                
646|                if (this.score > this.highScore) {
647|                    this.highScore = this.score;
648|                    localStorage.setItem('nobleak-best', this.highScore.toString());
649|                    document.getElementById('newRecord').style.display = 'block';
650|                } else {
651|                    document.getElementById('newRecord').style.display = 'none';
652|                }
653|                
654|                document.getElementById('finalScore').textContent = this.score;
655|                document.getElementById('totalCoins').textContent = this.coins;
656|                document.getElementById('gameOverScreen').style.display = 'flex';
657|            }
658|        }
659|        
660|        let game;
661|        
662|        function startGame() {
663|            document.getElementById('startScreen').style.display = 'none';
664|            document.getElementById('gameOverScreen').style.display = 'none';
665|            game.initGame();
666|        }
667|        
668|        // Initialize
669|        window.addEventListener('load', () => {
670|            game = new UltraGame();
671|        });
672|        
673|        // Optimized resize handler
674|        let resizeTimeout;
675|        window.addEventListener('resize', () => {
676|            clearTimeout(resizeTimeout);
677|            resizeTimeout = setTimeout(() => {
678|                if (game) game.setupCanvas();
679|            }, 150);
680|        });
681|    </script>
682|</body>
683|</html>

